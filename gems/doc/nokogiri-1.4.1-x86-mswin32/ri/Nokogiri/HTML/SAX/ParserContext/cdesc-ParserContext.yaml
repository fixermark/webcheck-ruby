--- !ruby/object:RI::ClassDescription 
attributes: []

class_methods: 
- !ruby/object:RI::MethodSummary 
  name: new
comment: 
- !ruby/struct:SM::Flow::P 
  body: "#include &lt;html_sax_parser_context.h&gt;"
- !ruby/struct:SM::Flow::P 
  body: VALUE cNokogiriHtmlSaxParserContext ;
- !ruby/struct:SM::Flow::P 
  body: static void deallocate(xmlParserCtxtPtr ctxt) {
- !ruby/struct:SM::Flow::VERB 
  body: "  NOKOGIRI_DEBUG_START(handler);\n\n  ctxt-&gt;sax = NULL;\n\n  htmlFreeParserCtxt(ctxt);\n\n  NOKOGIRI_DEBUG_END(handler);\n"
- !ruby/struct:SM::Flow::P 
  body: "}"
- !ruby/struct:SM::Flow::P 
  body: static VALUE parse_memory(VALUE klass, VALUE data, VALUE encoding) {
- !ruby/struct:SM::Flow::VERB 
  body: "  if(NIL_P(data)) rb_raise(rb_eArgError, &quot;data cannot be nil&quot;);\n  if(!(int)RSTRING_LEN(data))\n    rb_raise(rb_eRuntimeError, &quot;data cannot be empty&quot;);\n\n  htmlParserCtxtPtr ctxt = htmlCreateMemoryParserCtxt(\n      StringValuePtr(data),\n      (int)RSTRING_LEN(data)\n  );\n\n  if(RTEST(encoding)) {\n    xmlCharEncoding enc = xmlParseCharEncoding(StringValuePtr(encoding));\n    if(enc != XML_CHAR_ENCODING_ERROR) {\n      xmlSwitchEncoding(ctxt, enc);\n      if(ctxt-&gt;errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n        rb_raise(rb_eRuntimeError, &quot;Unsupported encoding %s&quot;,\n            StringValuePtr(encoding));\n      }\n    }\n  }\n\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n"
- !ruby/struct:SM::Flow::P 
  body: "}"
- !ruby/struct:SM::Flow::P 
  body: static VALUE parse_file(VALUE klass, VALUE filename, VALUE encoding) {
- !ruby/struct:SM::Flow::VERB 
  body: "  htmlParserCtxtPtr ctxt = htmlCreateFileParserCtxt(\n      StringValuePtr(filename),\n      StringValuePtr(encoding)\n  );\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n"
- !ruby/struct:SM::Flow::P 
  body: "}"
- !ruby/struct:SM::Flow::P 
  body: static VALUE parse_with(VALUE self, VALUE sax_handler) {
- !ruby/struct:SM::Flow::VERB 
  body: "  if(!rb_obj_is_kind_of(sax_handler, cNokogiriXmlSaxParser))\n    rb_raise(rb_eArgError, &quot;argument must be a Nokogiri::XML::SAX::Parser&quot;);\n\n  htmlParserCtxtPtr ctxt;\n  Data_Get_Struct(self, htmlParserCtxt, ctxt);\n\n  htmlSAXHandlerPtr sax;\n  Data_Get_Struct(sax_handler, htmlSAXHandler, sax);\n\n  // Free the sax handler since we'll assign our own\n  if(ctxt-&gt;sax &amp;&amp; ctxt-&gt;sax != (xmlSAXHandlerPtr)&amp;xmlDefaultSAXHandler)\n    xmlFree(ctxt-&gt;sax);\n\n  ctxt-&gt;sax = sax;\n  ctxt-&gt;userData = (void *)NOKOGIRI_SAX_TUPLE_NEW(ctxt, sax_handler);\n\n  htmlParseDocument(ctxt);\n\n  if(NULL != ctxt-&gt;myDoc) xmlFreeDoc(ctxt-&gt;myDoc);\n\n  NOKOGIRI_SAX_TUPLE_DESTROY(ctxt-&gt;userData);\n  return self;\n"
- !ruby/struct:SM::Flow::P 
  body: "}"
- !ruby/struct:SM::Flow::P 
  body: void init_html_sax_parser_context() {
- !ruby/struct:SM::Flow::VERB 
  body: "  VALUE nokogiri  = rb_define_module(&quot;Nokogiri&quot;);\n  VALUE xml       = rb_define_module_under(nokogiri, &quot;XML&quot;);\n  VALUE html      = rb_define_module_under(nokogiri, &quot;HTML&quot;);\n  VALUE sax       = rb_define_module_under(xml, &quot;SAX&quot;);\n  VALUE hsax      = rb_define_module_under(html, &quot;SAX&quot;);\n  VALUE pc        = rb_define_class_under(sax, &quot;ParserContext&quot;, rb_cObject);\n  VALUE klass     = rb_define_class_under(hsax, &quot;ParserContext&quot;, pc);\n\n  cNokogiriHtmlSaxParserContext = klass;\n\n  rb_define_singleton_method(klass, &quot;memory&quot;, parse_memory, 2);\n  rb_define_singleton_method(klass, &quot;file&quot;, parse_file, 2);\n\n  rb_define_method(klass, &quot;parse_with&quot;, parse_with, 1);\n"
- !ruby/struct:SM::Flow::P 
  body: "}"
constants: []

full_name: Nokogiri::HTML::SAX::ParserContext
includes: []

instance_methods: []

name: ParserContext
superclass: Nokogiri::XML::SAX::ParserContext
